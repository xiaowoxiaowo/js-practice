// IntersectionObserver API 是异步的，不随着目标元素的滚动同步触发。
// 规格写明，IntersectionObserver的实现，应该采用requestIdleCallback()，即只有线程空闲下来，
// 才会执行观察器。这意味着，这个观察器的优先级非常低，只在其他任务执行完，浏览器有了空闲才会执行。

// vue，react都可以用：
// 1.vue，首屏优化20多个模块，原来10多s，优化到1s秒多（具体到页面性能指标）
// 每个模块抽离成异步组件(更新只在组件内)，一开始只渲染容器，IntersectionObserver检测组件是否处于视图中，
// 然后加载异步组件。滚动距离比较大的时候，滚动时进行加载，还是会卡顿。
// IntersectionObserver每次有新的组件进入视图，push到一个数组，然后给后续的更新方法添加防抖300ms。
// 只当滚动停止时，才进行渲染（v-if设置为true），从数组最后位开始渲染（更新最新的组件），
// 通过setTimeout进行渐进式渲染，每次间隔50ms（留出一些时间给用户操作情况）。

// 数据请求相关：滚动停止才会触发数据请求（父页面），带上现在需要显示的组件的key值，然后传给各个子组件。
// 父组件只定义了20多个模块的变量名字，不需要响应式，把对象转为字符串然后在赋值给data，传给子组件。子组件里再去转成对象。